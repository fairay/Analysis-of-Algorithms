\section{Выбор языка программирования}
В качестве языка программирования был выбран C++, так как имеется опыт работы с ним, и с библиотеками, позволяющими провести исследование и тестирование программы. Также в языке имеются средства для отключения оптимизации компилятора.


\section{Листинг кода}
Реализация алгоритмов умножения матриц представлена на листингах 3.1-3.2.

\begin{lstlisting}[caption = Функция умножения матриц классическим алгоритмом.]
def lev_matrix(s1, s2, is_print=False):
	matr = [[0] * (len(s1)+1) for i in range(len(s2)+1)]
	
	for j in range(len(s1)+1):
		matr[0][j] = j
	for i in range(len(s2)+1):
		matr[i][0] = i
	
	for i in range(1, len(s2)+1):
		for j in range(1, len(s1)+1):
			add = 0 if s1[j-1] == s2[i-1] else 1
			matr[i][j] = min(matr[i-1][j]+1, matr[i][j-1]+1, matr[i-1][j-1]+add)
	
	if is_print:
		print("Расстояние:", matr[i][j])
		print_matrix(matr)
	return matr[i][j]
\end{lstlisting}

\begin{lstlisting}[caption = Функция умножения матриц алгоритмом Винограда.]
def _lev_rec(s1, s2, len1, len2):
	if len1 == 0: return len2
	elif len2 == 0: return len1
	else:
		return min(_lev_rec(s1, s2, len1, len2-1)+1,
				_lev_rec(s1, s2, len1-1, len2)+1,
				_lev_rec(s1, s2, len1-1, len2-1) + 
				(0 if s1[len1-1] == s2[len2-1]
				 else 1))
def lev_recursion(s1, s2, is_print=False):
	res = _lev_rec(s1, s2, len(s1), len(s2))
	if is_print:
		print("Расстояние:", res)
	return res
\end{lstlisting}

\section{Использованые оптимизации}
Для уменьшения трудоёмкости алгоритма Винограда над его исходной версией были проделаны следующие оптимизации:
\begin{itemize}
	\item При вычислении ячеек С, промежеточный результат записывается в временную переменную, которая после получения результата переносится в матрцу С. Таким образом снижено количество операций высчитывания адреса.
	\item Цикл по слагаемым (с переменной k) изменён на аналогичный с шагом 2. Таким образом, внутри цикла не требуется производить умножение k на 2.
	\item Также введена переменная k1, равная k-1. Она, как и k, увеличивается на каждом проходе цикла на 2, и таким образом вместо 2 операций (k-1) за цикл остаётся одна.
	\item Вычисление массива multi заменено на высчитывание значения mi = multi[i] внутри общего цикла. Таким образом удалось избавиться от накладных расходов для цикла и от выделения и освобождения памяти под массив.
\end{itemize}

\section{Результаты тестирования}
Для тестирования написанных функций был создан отдельный файл с вышеописаными классами тестов. Тестирование функций проводилось за счёт сравнения результов двух функций.

Состав тестов приведён в листинге 3.3.

\begin{lstlisting}[caption = Модульные тесты]
import unittest
import main

# Общий набор тестов для всех алгоритмов
class GeneralTest(unittest.TestCase):
	# Данный класс являтся абстрактным, поэтому для него тесты пропускаются
	@unittest.skip("Skip GeneralTest")
	def setUp(self):
		self.function = None
	
	# Проверка пустыми строками
	def test_empty(self):
		self.assertEqual(self.function("", ""), 0)
		self.assertEqual(self.function("a", ""), 1)
		self.assertEqual(self.function("", "b"), 1)
		
	# Проверка нахождения совпадений
	def test_match(self):
		self.assertEqual(self.function("abc", "abc"), 0)
		self.assertEqual(self.function("a", "a"), 0)
		self.assertEqual(self.function("A", "a"), 1)
	
	# Прочие общие тесты
	def test_other(self):
		self.assertEqual(self.function("q", "w"), 1)
		self.assertEqual(self.function("aq", "aw"), 1)
		self.assertEqual(self.function("a", "aw"), 1)
		self.assertEqual(self.function("aw", "a"), 1)


# Набор тестов для алгоритмов поиска расстояния Левенштейна
class LevTest(GeneralTest):
	def test_lev(self):
		self.assertEqual(self.function("stolb", "telo"), 3)
		self.assertEqual(self.function("kult_tela", "tela_kult"), 6)
		self.assertEqual(self.function("развлечение", "увлечение"), 3)


# Набор тестов для алгоритма поиска расстояния  Дамерау-Левенштейна
class DemLevMatrixTest(GeneralTest):
	def setUp(self):
		self.function = main.dem_lev_matrix

	def dem_lev_test(self):
		self.assertEqual(self.function("aba", "aab"), 1)
		self.assertEqual(self.function("ab", "ba"), 1)
		self.assertEqual(self.function("abb", "bab"), 1)


# Алгоритмы поиска расстояния Левенштейна проходят одинковые тесты из класса LevTest
# Алгоритм поиска расстояния Левенштейна, матричный метод
class LevMatrixTest(LevTest):
	def setUp(self):
		self.function = main.lev_matrix
# Алгоритм поиска расстояния Левенштейна, рекурсивный метод
class LevRecursionTest(LevTest):
	def setUp(self):
		self.function = main.lev_recursion
# Алгоритм поиска расстояния Левенштейна, рекурсивный метод с заполнением матрицы
class LevMatRecTest(LevTest):
	def setUp(self):
	self.function = main.lev_matrix_recursion

# Точка входа, запуск тестов
if __name__ == "__main__":
	unittest.main()
\end{lstlisting}

% //////////////
\section{Оценка трудоёмкости}
Произведём оценку трудоёмкости алгоритов. Будем считать, что умножаются матрицы $ A[M*N] $ и $ B[N*Q] $ 

\textbf{Классический алгоритм умножения.} 
\par $ f_{cls} = 2 + M\cdot(2 + Q\cdot(3 + 2 + N\cdot(2 + 1 + 2 + 1 + 2))) $
\par $ f_{cls} = 2 + 2M + 5QM + 10MNQ $\\

\textbf{Алгоритм умножения Винограда.} 
\par $ f_{win} = (2 + Q\cdot(2 + 1 + 1 + (N/2)\cdot(2 + 1 + 2 + 1 + 3))) + 
2 + M\cdot(2 + 1 + 2 + (N/2)\cdot(2 + 1 + 2 + 1 + 2) + 2 + Q\cdot(2 + 3 + 2 + 1 + (N/2)\cdot(3 + 1 + 5 + 1 + 5))) + 1 +
\left\{\begin{array}{ll}
	0, & $л.с.$\\
	2 + 2 + M\cdot(2 + Q\cdot(2 + 3 + 2 + 1 + 2)), & $х.с.$
\end{array} \right.$\\

\par $ f_{win} = 5 + 4Q + 4.5NQ + 
7M + 4MN + 8MQ + 7.5MNQ +
\left\{\begin{array}{ll}
	0, & $л.с.$\\
	4 + 2M + 10MQ, & $х.с.$
\end{array} \right.$



\section{Оценка времени}
Для замера процессорного времени исполнения функции используется библиотека windows.h. Проведение измерений производится в функции, приведённой в листинге 3.4

\begin{lstlisting}[caption = Функция замера процессорного времени работы функции]
def random_str(length):
	a = []
	for i in range(length):
		a.append(random.choice("qwerty"))
	return "".join(a)

def test_time(func):
	length = int(input("Введите длину строки: "))
	s1 = random_str(length)
	s2 = random_str(length)
	print("Строка 1:", s1)
	print("Строка 2:", s2)
	
	begin_t = time.process_time()
	count = 0
	while time.process_time() - begin_t < 1.0:
		func(s1, s2)
		count += 1
	
	t = time.process_time() - begin_t
	print("Выполнено {:} операций за {:} секунд".format(count, t))
	print("Время: {:7.4} секунд".format(t / count))
	\end{lstlisting}

